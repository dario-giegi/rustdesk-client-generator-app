name: Build RustDesk Client

on:
  workflow_dispatch:
    inputs:
      config_json:
        description: 'Configuration JSON'
        required: true
        type: string
      executable_name:
        description: 'Executable name'
        required: true
        type: string
        default: 'rustdesk-custom'
      rustdesk_branch:
        description: 'RustDesk branch'
        required: false
        type: string
        default: 'master'
      target_arch:
        description: 'Target architecture'
        required: false
        type: choice
        options:
          - x86_64
          - aarch64
        default: 'x86_64'
      enable_portable:
        description: 'Enable portable mode'
        required: false
        type: boolean
        default: true
      include_installer:
        description: 'Include installer'
        required: false
        type: boolean
        default: true
      enable_debug:
        description: 'Enable debug mode'
        required: false
        type: boolean
        default: false
      sign_executable:
        description: 'Sign executable'
        required: false
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  VCPKG_DEFAULT_TRIPLET: x64-windows-static

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
    - name: Checkout RustDesk
      uses: actions/checkout@v4
      with:
        repository: rustdesk/rustdesk
        ref: ${{ inputs.rustdesk_branch }}
        submodules: recursive
        path: rustdesk
        
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: x86_64-pc-windows-msvc
        
    - name: Install dependencies
      run: |
        choco install llvm -y
        pip install cffi
        
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        # Usar la versi√≥n m√°s reciente de vcpkg para tener todas las dependencias actualizadas
        vcpkgGitCommitId: 'd30fdf55cfca16e12bc3ad99cbc615997014b61b'
        
    - name: Install vcpkg dependencies
      run: |
        cd rustdesk
        
        # Verificar que existe el archivo vcpkg.json
        if [ ! -f "vcpkg.json" ]; then
          echo "Error: vcpkg.json no encontrado en el directorio rustdesk"
          exit 1
        fi
        
        echo "Archivo vcpkg.json encontrado, instalando dependencias en modo manifiesto..."
        
        # SOLUCI√ìN AL WARNING: "Use MSVC to compile libyuv results in a very slow library"
        # Este warning aparece porque MSVC produce una versi√≥n lenta de libyuv
        # Soluci√≥n: Usar Clang en lugar de MSVC para compilar las dependencias nativas
        
        # Configurar Clang como compilador para evitar el warning de rendimiento de libyuv con MSVC
        # Ref: https://github.com/microsoft/vcpkg/issues/28446
        export CC=clang
        export CXX=clang++
        export VCPKG_PLATFORM_TOOLSET=ClangCL
        
        echo "Configurando Clang como compilador para mejorar rendimiento de libyuv..."
        echo "CC=$CC, CXX=$CXX, VCPKG_PLATFORM_TOOLSET=$VCPKG_PLATFORM_TOOLSET"
        
        # En modo manifiesto, vcpkg usa el archivo vcpkg.json del proyecto RustDesk
        # Instalar dependencias usando el modo manifiesto con Clang
        # A√±adir flags de optimizaci√≥n para mejorar rendimiento
        export VCPKG_FEATURE_FLAGS="manifests,versions"
        export VCPKG_OVERLAY_TRIPLETS=""
        
        # Configurar flags de compilaci√≥n optimizados
        export CFLAGS="-O3 -march=native"
        export CXXFLAGS="-O3 -march=native"
        
        echo "Flags de optimizaci√≥n configurados: CFLAGS=$CFLAGS, CXXFLAGS=$CXXFLAGS"
        
        # SOLUCI√ìN ROBUSTA PARA ERRORES 503 DE DESCARGA DE OPUS Y LIBVPX
        # Configurar variables de entorno para mejorar descargas de vcpkg
        export VCPKG_MAX_CONCURRENCY=4
        export VCPKG_DOWNLOADS_RETRIES=5
        export VCPKG_DOWNLOADS_TIMEOUT=120
        export VCPKG_CURL_OPTIONS="--retry 5 --retry-delay 10 --connect-timeout 30"
        
        # Limpiar variables de proxy problem√°ticas que pueden causar errores 503
        unset https_proxy HTTPS_PROXY http_proxy HTTP_PROXY || true
        
        echo "Variables de descarga configuradas:"
        echo "VCPKG_MAX_CONCURRENCY=$VCPKG_MAX_CONCURRENCY"
        echo "VCPKG_DOWNLOADS_RETRIES=$VCPKG_DOWNLOADS_RETRIES"
        echo "VCPKG_DOWNLOADS_TIMEOUT=$VCPKG_DOWNLOADS_TIMEOUT"
        
        # Funci√≥n de instalaci√≥n con reintentos inteligentes
        install_vcpkg_dependencies() {
          local max_retries=5
          local retry_delay=30
          
          for attempt in $(seq 1 $max_retries); do
            echo "=== Intento $attempt de $max_retries para instalar dependencias vcpkg ==="
            
            # Verificar conectividad antes del intento
            if ! curl -s --connect-timeout 10 https://github.com >/dev/null; then
              echo "‚ö†Ô∏è Problema de conectividad detectado, esperando..."
              sleep $retry_delay
              continue
            fi
            
            # Intentar instalaci√≥n
            if vcpkg install --triplet x64-windows-static; then
              echo "‚úÖ Dependencias instaladas correctamente en el intento $attempt"
              return 0
            fi
            
            echo "‚ùå Fall√≥ la instalaci√≥n en el intento $attempt"
            
            # Si no es el √∫ltimo intento, limpiar cach√© y reintentar
            if [ $attempt -lt $max_retries ]; then
              echo "üßπ Limpiando cach√© de descargas y buildtrees problem√°ticos..."
              
              # Limpiar cach√© espec√≠fico de opus y libvpx
              rm -rf "$VCPKG_INSTALLATION_ROOT/buildtrees/opus" \
                     "$VCPKG_INSTALLATION_ROOT/buildtrees/libvpx" \
                     "$VCPKG_INSTALLATION_ROOT/downloads/opus"* \
                     "$VCPKG_INSTALLATION_ROOT/downloads/libvpx"* \
                     "$VCPKG_INSTALLATION_ROOT/downloads/_*opus*" \
                     "$VCPKG_INSTALLATION_ROOT/downloads/_*libvpx*" 2>/dev/null || true
              
              echo "‚è≥ Esperando $retry_delay segundos antes del siguiente intento..."
              sleep $retry_delay
              
              # Incrementar el delay para el siguiente intento
              retry_delay=$((retry_delay + 15))
            fi
          done
          
          echo "üí• ERROR: No se pudieron instalar las dependencias tras $max_retries intentos"
          echo "üîç Diagn√≥stico final:"
          echo "- Verificar conectividad a GitHub"
          echo "- Posibles problemas de proxy o firewall"
          echo "- Servidor de GitHub temporalmente no disponible"
          return 1
        }
        
        # Ejecutar instalaci√≥n con reintentos
        install_vcpkg_dependencies
        
        # Verificar que las dependencias se instalaron correctamente
        echo "Verificando instalaci√≥n de dependencias..."
        if [ -d "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/include/opus" ]; then
          echo "‚úÖ opus headers encontrados"
        else
          echo "‚ö†Ô∏è opus headers no encontrados en la ubicaci√≥n esperada"
        fi
        
        # Listar dependencias instaladas
        echo "Dependencias instaladas:"
        ls -la "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/include/" || echo "Directorio include no encontrado"
        
        # Verificar librer√≠as instaladas
        echo "Librer√≠as instaladas:"
        ls -la "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/lib/" || echo "Directorio lib no encontrado"
      shell: bash
        
    - name: Create config directory
      run: mkdir -p rustdesk/src/ui
      shell: bash
      
    - name: Write configuration
      run: |
        echo '${{ inputs.config_json }}' > rustdesk/src/ui/config.json
      shell: bash
      
    - name: Parse and apply configuration
      run: |
        cd rustdesk
        
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        
        # Crear archivo de configuraci√≥n Rust
        $rustConfig = @"
        // Auto-generated configuration
        pub const RENDEZVOUS_SERVER: &str = "$($config.server.RENDEZVOUS_SERVER)";
        pub const RELAY_SERVER: &str = "$($config.server.RELAY_SERVER)";
        pub const API_SERVER: &str = "$($config.server.API_SERVER)";
        pub const KEY: &str = "$($config.server.KEY)";
        pub const PRODUCT_NAME: &str = "$($config.branding.PRODUCT_NAME)";
        pub const APP_NAME: &str = "$($config.branding.APP_NAME)";
        "@
        
        $rustConfig | Out-File -FilePath "src/config.rs" -Encoding UTF8
        
        # Actualizar Cargo.toml con el nombre del producto
        $cargoToml = Get-Content "Cargo.toml" -Raw
        $cargoToml = $cargoToml -replace 'name = "rustdesk"', "name = `"$($config.branding.APP_NAME)`""
        # Corregir default-run para que apunte al target correcto (RustDesk con may√∫sculas)
        $cargoToml = $cargoToml -replace 'default-run = "rustdesk"', 'default-run = "RustDesk"'
        $cargoToml | Out-File -FilePath "Cargo.toml" -Encoding UTF8
        
      shell: powershell
      
    - name: Build RustDesk
      run: |
        cd rustdesk
        
        $env:VCPKG_ROOT = "$env:VCPKG_INSTALLATION_ROOT"
        $env:LIBCLANG_PATH = "$env:PROGRAMFILES\LLVM\bin"
        $env:CLANG_PATH = "$env:PROGRAMFILES\LLVM\bin\clang.exe"
        
        # Configurar variables de entorno para vcpkg en modo manifiesto
        $env:VCPKG_DEFAULT_TRIPLET = "x64-windows-static"
        $env:VCPKG_TARGET_TRIPLET = "x64-windows-static"
        $env:PKG_CONFIG_PATH = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib\pkgconfig"
        
        # Configurar variables espec√≠ficas para linking est√°tico
        $env:RUSTFLAGS = "-C target-feature=+crt-static"
        
        # SOLUCI√ìN MEJORADA PARA ERRORES DE HEADERS NO ENCONTRADOS EN MAGNUM-OPUS Y SCRAP
        # Configuramos variables espec√≠ficas para opus y vpx, y mejoramos bindgen
        # para que pueda encontrar todos los headers necesarios
        
        # Configurar variables espec√≠ficas para magnum-opus y headers de opus
        $env:OPUS_INCLUDE_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:OPUS_LIB_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        $env:OPUS_STATIC = "1"
        $env:OPUS_NO_PKG = "1"
        
        # Variables adicionales para magnum-opus
        $env:DEP_OPUS_INCLUDE = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:DEP_OPUS_LIB = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        $env:DEP_OPUS_STATIC = "1"
        
        # Configurar variables espec√≠ficas para scrap y headers de vpx
        $env:VPX_INCLUDE_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:VPX_LIB_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        $env:VPX_STATIC = "1"
        $env:VPX_NO_PKG = "1"
        
        # Configurar bindgen con m√∫ltiples rutas de include
        $includeDir = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:BINDGEN_EXTRA_CLANG_ARGS = "-I$includeDir -I$includeDir\opus -I$includeDir\vpx --sysroot=$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static"
        
        # Variables adicionales para build scripts y compatibilidad
        $env:CPPFLAGS = "-I$includeDir -I$includeDir\opus -I$includeDir\vpx"
        $env:LDFLAGS = "-L$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        
        # Variables adicionales para bindgen y clang
        $env:LIBCLANG_INCLUDE_PATH = "$includeDir"
        $env:C_INCLUDE_PATH = "$includeDir"
        $env:CPLUS_INCLUDE_PATH = "$includeDir"
        
        # Variables adicionales para compatibilidad con diferentes build scripts
        $env:OPUS_LIBS = "-lopus"
        $env:OPUS_CFLAGS = "-I$includeDir\opus"
        
        # Verificar configuraci√≥n de vcpkg
        Write-Host "=== Configuraci√≥n de vcpkg ==="
        Write-Host "VCPKG_ROOT: $env:VCPKG_ROOT"
        Write-Host "VCPKG_DEFAULT_TRIPLET: $env:VCPKG_DEFAULT_TRIPLET"
        Write-Host "PKG_CONFIG_PATH: $env:PKG_CONFIG_PATH"
        Write-Host "OPUS_INCLUDE_DIR: $env:OPUS_INCLUDE_DIR"
        Write-Host "OPUS_LIB_DIR: $env:OPUS_LIB_DIR"
        Write-Host "BINDGEN_EXTRA_CLANG_ARGS: $env:BINDGEN_EXTRA_CLANG_ARGS"
        
        # Verificar que los headers est√°n disponibles
        Write-Host "=== Verificando headers instalados ==="
        if (Test-Path "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include") {
          Write-Host "Directorio include encontrado, listando contenido:"
          Get-ChildItem "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include" | Select-Object -First 20
        } else {
          Write-Host "‚ùå Directorio include no encontrado"
        }
        
        # Verificar espec√≠ficamente los headers de opus que necesita magnum-opus
        Write-Host "=== Verificando headers espec√≠ficos de opus ==="
        $opusHeaders = @(
          "opus\opus.h",
          "opus\opus_multistream.h", 
          "opus\opus_defines.h",
          "opus\opus_types.h"
        )
        
        foreach ($header in $opusHeaders) {
          $headerPath = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include\$header"
          if (Test-Path $headerPath) {
            Write-Host "‚úÖ $header encontrado"
          } else {
            Write-Host "‚ùå $header NO encontrado en $headerPath"
          }
        }
        
        # Verificar espec√≠ficamente los headers de vpx que necesita scrap
        Write-Host "=== Verificando headers espec√≠ficos de vpx ==="
        $vpxHeaders = @(
          "vpx\vp8.h",
          "vpx\vp8cx.h",
          "vpx\vp8dx.h",
          "vpx\vpx_codec.h",
          "vpx\vpx_decoder.h",
          "vpx\vpx_encoder.h"
        )
        
        foreach ($header in $vpxHeaders) {
          $headerPath = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include\$header"
          if (Test-Path $headerPath) {
            Write-Host "‚úÖ $header encontrado"
          } else {
            Write-Host "‚ùå $header NO encontrado en $headerPath"
          }
        }
        
        # Verificar librer√≠as instaladas
        Write-Host "=== Verificando librer√≠as instaladas ==="
        if (Test-Path "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib") {
          Write-Host "Librer√≠as encontradas:"
          Get-ChildItem "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib" -Filter "*.lib" | Select-Object Name | ForEach-Object { Write-Host "  - $($_.Name)" }
        } else {
          Write-Host "‚ùå Directorio lib no encontrado"
        }
        
        Write-Host "=== Iniciando compilaci√≥n de RustDesk ==="
        Write-Host "Modo debug habilitado: ${{ inputs.enable_debug }}"
        
        # Compilar con informaci√≥n verbosa para diagn√≥stico
        $env:RUST_BACKTRACE = "1"
        $env:RUST_LOG = "debug"
        
        if ("${{ inputs.enable_debug }}" -eq "true") {
          cargo build --release --features inline --verbose
        } else {
          cargo build --release --features inline --verbose
        }
      shell: powershell
      
    - name: Prepare executable
      run: |
        cd rustdesk
        
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $executableName = "${{ inputs.executable_name }}"
        
        # Buscar el ejecutable generado (puede ser RustDesk.exe o el nombre personalizado)
        $builtExecutable = ""
        if (Test-Path "target/release/RustDesk.exe") {
          $builtExecutable = "target/release/RustDesk.exe"
        } elseif (Test-Path "target/release/rustdesk.exe") {
          $builtExecutable = "target/release/rustdesk.exe"
        } elseif (Test-Path "target/release/$($config.branding.APP_NAME).exe") {
          $builtExecutable = "target/release/$($config.branding.APP_NAME).exe"
        } else {
          Write-Error "No se encontr√≥ el ejecutable compilado"
          exit 1
        }
        
        Write-Host "Ejecutable encontrado: $builtExecutable"
        
        # Copiar el ejecutable con el nombre personalizado si es diferente
        if ($builtExecutable -ne "target/release/$executableName.exe") {
          Copy-Item $builtExecutable "target/release/$executableName.exe"
        }
        
        # Si es modo portable, crear el archivo .portable
        if ("${{ inputs.enable_portable }}" -eq "true") {
          New-Item -Path "target/release/$executableName.portable" -ItemType File
        }
      shell: powershell
      
    - name: Create installer (if enabled)
      if: inputs.include_installer == true
      run: |
        cd rustdesk
        
        # Instalar NSIS
        choco install nsis -y
        
        # Crear script NSIS b√°sico
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $executableName = "${{ inputs.executable_name }}"
        
        $nsisScript = @"
        !define PRODUCT_NAME "$($config.branding.PRODUCT_NAME)"
        !define PRODUCT_VERSION "$($config.build.VERSION)"
        !define PRODUCT_PUBLISHER "$($config.branding.PRODUCT_NAME)"
        !define PRODUCT_WEB_SITE "https://rustdesk.com"
        !define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\$executableName.exe"
        !define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\`${PRODUCT_NAME}"
        
        SetCompressor lzma
        
        Name "`${PRODUCT_NAME}"
        OutFile "$executableName-installer.exe"
        InstallDir "`$PROGRAMFILES\`${PRODUCT_NAME}"
        
        Section "MainSection" SEC01
          SetOutPath "`$INSTDIR"
          File "target\release\$executableName.exe"
          CreateDirectory "`$SMPROGRAMS\`${PRODUCT_NAME}"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\`${PRODUCT_NAME}.lnk" "`$INSTDIR\$executableName.exe"
          CreateShortCut "`$DESKTOP\`${PRODUCT_NAME}.lnk" "`$INSTDIR\$executableName.exe"
        SectionEnd
        
        Section -AdditionalIcons
          WriteIniStr "`$INSTDIR\`${PRODUCT_NAME}.url" "InternetShortcut" "URL" "`${PRODUCT_WEB_SITE}"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\Website.lnk" "`$INSTDIR\`${PRODUCT_NAME}.url"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\Uninstall.lnk" "`$INSTDIR\uninst.exe"
        SectionEnd
        
        Section -Post
          WriteUninstaller "`$INSTDIR\uninst.exe"
          WriteRegStr HKLM "`${PRODUCT_DIR_REGKEY}" "" "`$INSTDIR\$executableName.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayName" "`$(^Name)"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "UninstallString" "`$INSTDIR\uninst.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayIcon" "`$INSTDIR\$executableName.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayVersion" "`${PRODUCT_VERSION}"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "URLInfoAbout" "`${PRODUCT_WEB_SITE}"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "Publisher" "`${PRODUCT_PUBLISHER}"
        SectionEnd
        "@
        
        $nsisScript | Out-File -FilePath "installer.nsi" -Encoding UTF8
        
        # Compilar el instalador
        & "C:\Program Files (x86)\NSIS\makensis.exe" installer.nsi
      shell: powershell
      
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rustdesk-${{ inputs.executable_name }}-windows-${{ inputs.target_arch }}
        path: |
          rustdesk/target/release/${{ inputs.executable_name }}.exe
          rustdesk/target/release/${{ inputs.executable_name }}.portable
          rustdesk/${{ inputs.executable_name }}-installer.exe
        retention-days: 30
        
    - name: Create release info
      run: |
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $releaseInfo = @{
          executable_name = "${{ inputs.executable_name }}"
          version = $config.build.VERSION
          architecture = "${{ inputs.target_arch }}"
          platform = "windows"
          portable = "${{ inputs.enable_portable }}"
          installer = "${{ inputs.include_installer }}"
          server = $config.server.RENDEZVOUS_SERVER
          product_name = $config.branding.PRODUCT_NAME
          build_date = (Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")
        }
        
        $releaseInfo | ConvertTo-Json | Out-File -FilePath "release-info.json" -Encoding UTF8
      shell: powershell
      
    - name: Upload release info
      uses: actions/upload-artifact@v4
      with:
        name: release-info
        path: release-info.json
        retention-days: 30