name: Build RustDesk Client

on:
  workflow_dispatch:
    inputs:
      config_json:
        description: 'Configuration JSON'
        required: true
        type: string
      executable_name:
        description: 'Executable name'
        required: true
        type: string
        default: 'rustdesk-custom'
      rustdesk_branch:
        description: 'RustDesk branch'
        required: false
        type: string
        default: 'master'
      target_arch:
        description: 'Target architecture'
        required: false
        type: choice
        options:
          - x86_64
          - aarch64
        default: 'x86_64'
      enable_portable:
        description: 'Enable portable mode'
        required: false
        type: boolean
        default: true
      include_installer:
        description: 'Include installer'
        required: false
        type: boolean
        default: true
      enable_debug:
        description: 'Enable debug mode'
        required: false
        type: boolean
        default: false
      sign_executable:
        description: 'Sign executable'
        required: false
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  VCPKG_DEFAULT_TRIPLET: x64-windows-static

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
    - name: Checkout RustDesk
      uses: actions/checkout@v4
      with:
        repository: rustdesk/rustdesk
        ref: ${{ inputs.rustdesk_branch }}
        submodules: recursive
        path: rustdesk
        
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: x86_64-pc-windows-msvc
        
    - name: Install dependencies
      run: |
        choco install llvm -y
        pip install cffi
        
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        # Usar la versión más reciente de vcpkg para tener todas las dependencias actualizadas
        vcpkgGitCommitId: 'd30fdf55cfca16e12bc3ad99cbc615997014b61b'
        
    - name: Install vcpkg dependencies
      run: |
        cd rustdesk
        
        # Verificar que existe el archivo vcpkg.json
        if [ ! -f "vcpkg.json" ]; then
          echo "Error: vcpkg.json no encontrado en el directorio rustdesk"
          exit 1
        fi
        
        echo "Archivo vcpkg.json encontrado, instalando dependencias en modo manifiesto..."
        
        # SOLUCIÓN AL WARNING: "Use MSVC to compile libyuv results in a very slow library"
        # Este warning aparece porque MSVC produce una versión lenta de libyuv
        # Solución: Usar Clang en lugar de MSVC para compilar las dependencias nativas
        
        # Configurar Clang como compilador para evitar el warning de rendimiento de libyuv con MSVC
        # Ref: https://github.com/microsoft/vcpkg/issues/28446
        export CC=clang
        export CXX=clang++
        export VCPKG_PLATFORM_TOOLSET=ClangCL
        
        echo "Configurando Clang como compilador para mejorar rendimiento de libyuv..."
        echo "CC=$CC, CXX=$CXX, VCPKG_PLATFORM_TOOLSET=$VCPKG_PLATFORM_TOOLSET"
        
        # En modo manifiesto, vcpkg usa el archivo vcpkg.json del proyecto RustDesk
        # Instalar dependencias usando el modo manifiesto con Clang
        # Añadir flags de optimización para mejorar rendimiento
        export VCPKG_FEATURE_FLAGS="manifests,versions"
        export VCPKG_OVERLAY_TRIPLETS=""
        
        # Configurar flags de compilación optimizados
        export CFLAGS="-O3 -march=native"
        export CXXFLAGS="-O3 -march=native"
        
        echo "Flags de optimización configurados: CFLAGS=$CFLAGS, CXXFLAGS=$CXXFLAGS"
        
        vcpkg install --triplet x64-windows-static
        
        # Verificar que las dependencias se instalaron correctamente
        echo "Verificando instalación de dependencias..."
        if [ -d "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/include/opus" ]; then
          echo "✅ opus headers encontrados"
        else
          echo "⚠️ opus headers no encontrados en la ubicación esperada"
        fi
        
        # Listar dependencias instaladas
        echo "Dependencias instaladas:"
        ls -la "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/include/" || echo "Directorio include no encontrado"
        
        # Verificar librerías instaladas
        echo "Librerías instaladas:"
        ls -la "$VCPKG_INSTALLATION_ROOT/installed/x64-windows-static/lib/" || echo "Directorio lib no encontrado"
      shell: bash
        
    - name: Create config directory
      run: mkdir -p rustdesk/src/ui
      shell: bash
      
    - name: Write configuration
      run: |
        echo '${{ inputs.config_json }}' > rustdesk/src/ui/config.json
      shell: bash
      
    - name: Parse and apply configuration
      run: |
        cd rustdesk
        
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        
        # Crear archivo de configuración Rust
        $rustConfig = @"
        // Auto-generated configuration
        pub const RENDEZVOUS_SERVER: &str = "$($config.server.RENDEZVOUS_SERVER)";
        pub const RELAY_SERVER: &str = "$($config.server.RELAY_SERVER)";
        pub const API_SERVER: &str = "$($config.server.API_SERVER)";
        pub const KEY: &str = "$($config.server.KEY)";
        pub const PRODUCT_NAME: &str = "$($config.branding.PRODUCT_NAME)";
        pub const APP_NAME: &str = "$($config.branding.APP_NAME)";
        "@
        
        $rustConfig | Out-File -FilePath "src/config.rs" -Encoding UTF8
        
        # Actualizar Cargo.toml con el nombre del producto
        $cargoToml = Get-Content "Cargo.toml" -Raw
        $cargoToml = $cargoToml -replace 'name = "rustdesk"', "name = `"$($config.branding.APP_NAME)`""
        # Corregir default-run para que apunte al target correcto (RustDesk con mayúsculas)
        $cargoToml = $cargoToml -replace 'default-run = "rustdesk"', 'default-run = "RustDesk"'
        $cargoToml | Out-File -FilePath "Cargo.toml" -Encoding UTF8
        
      shell: powershell
      
    - name: Build RustDesk
      run: |
        cd rustdesk
        
        $env:VCPKG_ROOT = "$env:VCPKG_INSTALLATION_ROOT"
        $env:LIBCLANG_PATH = "$env:PROGRAMFILES\LLVM\bin"
        $env:CLANG_PATH = "$env:PROGRAMFILES\LLVM\bin\clang.exe"
        
        # Configurar variables de entorno para vcpkg en modo manifiesto
        $env:VCPKG_DEFAULT_TRIPLET = "x64-windows-static"
        $env:VCPKG_TARGET_TRIPLET = "x64-windows-static"
        $env:PKG_CONFIG_PATH = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib\pkgconfig"
        
        # Configurar variables específicas para linking estático
        $env:RUSTFLAGS = "-C target-feature=+crt-static"
        
        # Configurar variables específicas para magnum-opus y headers de opus
        $env:OPUS_INCLUDE_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:OPUS_LIB_DIR = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        $env:OPUS_STATIC = "1"
        $env:BINDGEN_EXTRA_CLANG_ARGS = "-I$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        
        # Variables adicionales para magnum-opus build script
        $env:OPUS_NO_PKG = "1"
        $env:CPPFLAGS = "-I$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include"
        $env:LDFLAGS = "-L$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\lib"
        
        # Verificar configuración de vcpkg
        Write-Host "Configuración de vcpkg:"
        Write-Host "VCPKG_ROOT: $env:VCPKG_ROOT"
        Write-Host "VCPKG_DEFAULT_TRIPLET: $env:VCPKG_DEFAULT_TRIPLET"
        Write-Host "PKG_CONFIG_PATH: $env:PKG_CONFIG_PATH"
        Write-Host "OPUS_INCLUDE_DIR: $env:OPUS_INCLUDE_DIR"
        Write-Host "OPUS_LIB_DIR: $env:OPUS_LIB_DIR"
        Write-Host "BINDGEN_EXTRA_CLANG_ARGS: $env:BINDGEN_EXTRA_CLANG_ARGS"
        
        # Verificar que los headers están disponibles
        Write-Host "Verificando headers instalados:"
        if (Test-Path "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include") {
          Get-ChildItem "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include" | Select-Object -First 20
        } else {
          Write-Host "Include directory not found"
        }
        
        # Verificar específicamente los headers de opus que necesita magnum-opus
        Write-Host "Verificando headers específicos de opus:"
        $opusHeaders = @(
          "opus\opus.h",
          "opus\opus_multistream.h", 
          "opus\opus_defines.h",
          "opus\opus_types.h"
        )
        
        foreach ($header in $opusHeaders) {
          $headerPath = "$env:VCPKG_INSTALLATION_ROOT\installed\x64-windows-static\include\$header"
          if (Test-Path $headerPath) {
            Write-Host "✅ $header encontrado"
          } else {
            Write-Host "❌ $header NO encontrado en $headerPath"
          }
        }
        
        Write-Host "Iniciando compilación de RustDesk..."
        if ("${{ inputs.enable_debug }}" -eq "true") {
          cargo build --release --features inline
        } else {
          cargo build --release --features inline
        }
      shell: powershell
      
    - name: Prepare executable
      run: |
        cd rustdesk
        
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $executableName = "${{ inputs.executable_name }}"
        
        # Buscar el ejecutable generado (puede ser RustDesk.exe o el nombre personalizado)
        $builtExecutable = ""
        if (Test-Path "target/release/RustDesk.exe") {
          $builtExecutable = "target/release/RustDesk.exe"
        } elseif (Test-Path "target/release/rustdesk.exe") {
          $builtExecutable = "target/release/rustdesk.exe"
        } elseif (Test-Path "target/release/$($config.branding.APP_NAME).exe") {
          $builtExecutable = "target/release/$($config.branding.APP_NAME).exe"
        } else {
          Write-Error "No se encontró el ejecutable compilado"
          exit 1
        }
        
        Write-Host "Ejecutable encontrado: $builtExecutable"
        
        # Copiar el ejecutable con el nombre personalizado si es diferente
        if ($builtExecutable -ne "target/release/$executableName.exe") {
          Copy-Item $builtExecutable "target/release/$executableName.exe"
        }
        
        # Si es modo portable, crear el archivo .portable
        if ("${{ inputs.enable_portable }}" -eq "true") {
          New-Item -Path "target/release/$executableName.portable" -ItemType File
        }
      shell: powershell
      
    - name: Create installer (if enabled)
      if: inputs.include_installer == true
      run: |
        cd rustdesk
        
        # Instalar NSIS
        choco install nsis -y
        
        # Crear script NSIS básico
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $executableName = "${{ inputs.executable_name }}"
        
        $nsisScript = @"
        !define PRODUCT_NAME "$($config.branding.PRODUCT_NAME)"
        !define PRODUCT_VERSION "$($config.build.VERSION)"
        !define PRODUCT_PUBLISHER "$($config.branding.PRODUCT_NAME)"
        !define PRODUCT_WEB_SITE "https://rustdesk.com"
        !define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\$executableName.exe"
        !define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\`${PRODUCT_NAME}"
        
        SetCompressor lzma
        
        Name "`${PRODUCT_NAME}"
        OutFile "$executableName-installer.exe"
        InstallDir "`$PROGRAMFILES\`${PRODUCT_NAME}"
        
        Section "MainSection" SEC01
          SetOutPath "`$INSTDIR"
          File "target\release\$executableName.exe"
          CreateDirectory "`$SMPROGRAMS\`${PRODUCT_NAME}"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\`${PRODUCT_NAME}.lnk" "`$INSTDIR\$executableName.exe"
          CreateShortCut "`$DESKTOP\`${PRODUCT_NAME}.lnk" "`$INSTDIR\$executableName.exe"
        SectionEnd
        
        Section -AdditionalIcons
          WriteIniStr "`$INSTDIR\`${PRODUCT_NAME}.url" "InternetShortcut" "URL" "`${PRODUCT_WEB_SITE}"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\Website.lnk" "`$INSTDIR\`${PRODUCT_NAME}.url"
          CreateShortCut "`$SMPROGRAMS\`${PRODUCT_NAME}\Uninstall.lnk" "`$INSTDIR\uninst.exe"
        SectionEnd
        
        Section -Post
          WriteUninstaller "`$INSTDIR\uninst.exe"
          WriteRegStr HKLM "`${PRODUCT_DIR_REGKEY}" "" "`$INSTDIR\$executableName.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayName" "`$(^Name)"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "UninstallString" "`$INSTDIR\uninst.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayIcon" "`$INSTDIR\$executableName.exe"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "DisplayVersion" "`${PRODUCT_VERSION}"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "URLInfoAbout" "`${PRODUCT_WEB_SITE}"
          WriteRegStr HKLM "`${PRODUCT_UNINST_KEY}" "Publisher" "`${PRODUCT_PUBLISHER}"
        SectionEnd
        "@
        
        $nsisScript | Out-File -FilePath "installer.nsi" -Encoding UTF8
        
        # Compilar el instalador
        & "C:\Program Files (x86)\NSIS\makensis.exe" installer.nsi
      shell: powershell
      
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rustdesk-${{ inputs.executable_name }}-windows-${{ inputs.target_arch }}
        path: |
          rustdesk/target/release/${{ inputs.executable_name }}.exe
          rustdesk/target/release/${{ inputs.executable_name }}.portable
          rustdesk/${{ inputs.executable_name }}-installer.exe
        retention-days: 30
        
    - name: Create release info
      run: |
        $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        $releaseInfo = @{
          executable_name = "${{ inputs.executable_name }}"
          version = $config.build.VERSION
          architecture = "${{ inputs.target_arch }}"
          platform = "windows"
          portable = "${{ inputs.enable_portable }}"
          installer = "${{ inputs.include_installer }}"
          server = $config.server.RENDEZVOUS_SERVER
          product_name = $config.branding.PRODUCT_NAME
          build_date = (Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")
        }
        
        $releaseInfo | ConvertTo-Json | Out-File -FilePath "release-info.json" -Encoding UTF8
      shell: powershell
      
    - name: Upload release info
      uses: actions/upload-artifact@v4
      with:
        name: release-info
        path: release-info.json
        retention-days: 30